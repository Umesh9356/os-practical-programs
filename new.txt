/* 2a.Implement the C or cpp program in which main program accepts the integers to be 
sorted.  
Main program uses the FORK system call to create a new process called a child 
process.  
Parent process sorts the integers using sorting algorithm and waits for child process 
using WAIT system call to sort the 
 integers using any sorting algorithm. Also demonstrate zombie and orphan states.*/ 
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <sys/types.h> 
#include <sys/wait.h> 
#define SIZE 5 
void sort_array(int *arr, int size) { 
    int temp; 
    for (int i = 0; i < size - 1; i++) { 
        for (int j = i + 1; j < size; j++) { 
            if (arr[i] > arr[j]) { 
                temp = arr[i]; 
                arr[i] = arr[j]; 
                arr[j] = temp; 
            }}}} 
void print_array(int *arr, int size) { 
    for (int i = 0; i < size; i++) 
        printf("%d ", arr[i]); 
    printf("\n"); 
} 
int main() { 
    int arr[SIZE] = {5, 2, 9, 1, 5}; 
    pid_t pid; 
    int status; 
    printf("Unsorted array: "); 
    print_array(arr, SIZE); 
    pid = fork(); 
    if (pid < 0) { 
        perror("fork failed"); 
        exit(EXIT_FAILURE); 
    } 
    if (pid == 0) { 
        // CHILD PROCESS 
        printf("\n--- CHILD PROCESS ---\n"); 
        printf("Child PID: %d, Parent PID: %d\n", getpid(), getppid()); 
        sort_array(arr, SIZE); 
        printf("Sorted array by child: "); 
        print_array(arr, SIZE); 
        printf("Child exiting now...\n"); 
        printf("Child becomes ZOMBIE until parent calls wait().\n"); 
        exit(EXIT_SUCCESS); 
    }  
else { 
        // PARENT PROCESS 
        printf("\n--- PARENT PROCESS ---\n"); 
        printf("Parent PID: %d, Child PID: %d\n", getpid(), pid); 
        printf("Parent sleeping for 10 seconds... (Child will finish and become Zombie)\n"); 
        printf("Check zombie using: ps -l | grep %d\n", pid); 
        sleep(10); 
  waitpid(pid, &status, 0); 
        printf("\nParent collected zombie (wait done)\n"); 
 // ORPHAN DEMO 
        pid_t pid2 = fork(); 
      if (pid2 == 0) { 
            printf("\n--- NEW CHILD PROCESS (Orphan Demo) ---\n"); 
            printf("Child PID: %d, Parent PID: %d\n", getpid(), getppid()); 
            printf("Sleeping 5 seconds so parent exits first...\n"); 
            sleep(5); 
            printf("Now my Parent PID changed to %d (init/systemd)\n", getppid()); 
            printf("I am now an ORPHAN process.\n"); 
            exit(0); 
        } else { 
            printf("\nParent exiting now... (Next child will become orphan)\n"); 
            exit(0); 
        } 
    } 
    return 0; 
} 
 
 
 
 
 
 
 
/*2b.Implement the C program in which main program accepts an array.  
Main program uses the FORK system call to create a new process called a child 
process.  
Parent process sorts an array and passes the sorted array to child process through the 
command line arguments of EXECVE system call. 
The child process uses EXECVE system call to load new program which display array in 
reverse order.*/ 
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <sys/types.h> 
#include <sys/wait.h> 
// Function to sort array in ascending order 
void sortArray(int arr[], int n) { 
    int temp; 
    for (int i = 0; i < n - 1; i++) { 
        for (int j = i + 1; j < n; j++) { 
            if (arr[i] > arr[j]) { 
                temp = arr[i]; 
                arr[i] = arr[j]; 
                arr[j] = temp; 
            }}}} 
int main() { 
    int n; 
    printf("Enter number of elements: "); 
    scanf("%d", &n); 
    int arr[n]; 
    printf("Enter %d elements:\n", n); 
    for (int i = 0; i < n; i++) { 
        scanf("%d", &arr[i]); 
    } 
    // Sort array before sending 
    sortArray(arr, n); 
    printf("\n[Main Program] Sorted array: "); 
    for (int i = 0; i < n; i++) { 
        printf("%d ", arr[i]); 
    } 
    printf("\n"); 
    pid_t pid = fork(); 
    if (pid < 0) { 
        perror("Fork failed"); 
        exit(1); 
    }  
    else if (pid == 0) { 
        // Child process executes new program using execve() 
        printf("\n[Child] Executing displayrev program using execve()...\n"); 
        // Prepare arguments 
        char *args[n + 2]; 
        args[0] = "./displayrev"; 
        for (int i = 0; i < n; i++) { 
            char *num = malloc(10); 
            sprintf(num, "%d", arr[i]); 
            args[i + 1] = num; 
        } 
        args[n + 1] = NULL; 
        execve("./displayrev", args, NULL); 
        perror("execve failed"); 
        exit(1); 
    }  
    else { 
        // Parent waits for child 
        wait(NULL); 
        printf("\n[Main Program] Child process finished.\n"); 
    } 
    return 0; 
} 
*/display rev Program 
#include <stdio.h> 
#include <stdlib.h> 
int main(int argc, char *argv[]) { 
    int n = argc - 1; 
    int arr[n]; 
    for (int i = 1; i < argc; i++) { 
        arr[i - 1] = atoi(argv[i]); 
    } 
    printf("\n[Display Program] Array in reverse order: "); 
    for (int i = n - 1; i >= 0; i--) { 
        printf("%d ", arr[i]); 
    } 
    printf("\n"); 
return 0; 
}            
3a.   
#include <stdio.h> 
// Structure to represent a process 
struct process { 
    int pid;     // Process ID 
    int at;      // Arrival Time 
    int bt;      // Burst Time 
    int ct;      // Completion Time 
    int tat;     // Turnaround Time 
    int wt;      // Waiting Time 
    int rem_bt;  // Remaining Burst Time (used for preemption) 
}; 
int main() { 
    int n;                         // Number of processes 
    int completed = 0;             // Count of completed processes 
    int time = 0;                  // Current time 
    int min_bt, idx = -1;          // To find the process with shortest remaining time 
    struct process p[10];          // Array to store process information 
    float avgwt = 0, avgtat = 0;   // For average waiting and turnaround time 
    int is_completed[10] = {0};    // Flags to check if a process is completed 
   // ------------------------------- 
    // Step 1: Input process details 
    // ------------------------------- 
    printf("Enter number of processes: "); 
    scanf("%d", &n); 
for (int i = 0; i < n; i++) { 
        p[i].pid = i + 1; // Assign process ID (P1, P2, P3, ...) 
        printf("Enter Arrival Time for P%d: ", i + 1); 
        scanf("%d", &p[i].at); 
        printf("Enter Burst Time for P%d: ", i + 1); 
        scanf("%d", &p[i].bt); 
        // Initially, remaining burst time = total burst time 
        p[i].rem_bt = p[i].bt; 
    } 
    printf("\n--- Preemptive Shortest Job First (SRTF) Scheduling ---\n"); 
    // -------------------------------------------------- 
    // Step 2: Run until all processes are completed 
    // -------------------------------------------------- 
    while (completed != n) { 
        min_bt = 9999; // Large number to find minimum 
        idx = -1;      // Index of process to execute next 
 
        // Find process with minimum remaining burst time that has arrived 
        for (int i = 0; i < n; i++) { 
            if (p[i].at <= time && is_completed[i] == 0 && p[i].rem_bt < min_bt && p[i].rem_bt > 
0) { 
                min_bt = p[i].rem_bt; 
                idx = i; 
            }} 
// If a process is found to execute 
        if (idx != -1) { 
            p[idx].rem_bt--; // Execute the process for 1 unit of time 5 4 
            time++;          // Increment current time 4 5 
 // If process completes its execution 
            if (p[idx].rem_bt == 0) { 
                p[idx].ct = time;                      // Completion time 
                p[idx].tat = p[idx].ct - p[idx].at;    // Turnaround time = CT - AT 
                p[idx].wt = p[idx].tat - p[idx].bt;    // Waiting time = TAT - BT 
 // Add to totals for average calculations 
                avgwt += p[idx].wt; 
                avgtat += p[idx].tat; 
  is_completed[idx] = 1; // Mark process as completed 
                completed++;// Increment completed count 
            } }  
        else { 
            // If no process has arrived yet at current time 
            time++; 
        }} 
// -------------------------------------------- 
    // Step 3: Display results in table format 
    // -------------------------------------------- 
    printf("\nPID\tAT\tBT\tCT\tTAT\tWT\n"); 
    for (int i = 0; i < n; i++) { 
        printf("%d\t%d\t%d\t%d\t%d\t%d\n",  
               p[i].pid, p[i].at, p[i].bt, p[i].ct, p[i].tat, p[i].wt); 
    }    // -------------------------------------------- 
    // Step 4: Print average waiting and turnaround 
    // -------------------------------------------- 
    printf("\nAverage Waiting Time: %.2f", avgwt / n); 
    printf("\nAverage Turnaround Time: %.2f\n", avgtat / n); 
return 0; 
} 
            
3b. 
#include <stdio.h> 
//    Define structure to hold process details 
struct Process { 
    int pid;    // Process ID 
    int at;     // Arrival Time 
    int bt;     // Burst Time 
    int rt;     // Remaining Time 
    int ct;     // Completion Time 
    int tat;    // Turnaround Time 
    int wt;     // Waiting Time 
}; 
int main() { 
    int n, tq; 
    //   Step 1: Input number of processes 
    printf("Enter number of processes: "); 
    scanf("%d", &n);  //n=4 
  struct Process p[n]; 
    //   Step 2: Input Arrival Time and Burst Time for each process 
    for (int i = 0; i < n; i++) { 
        p[i].pid = i + 1; 
        printf("Enter Arrival Time and Burst Time for Process %d: ", p[i].pid); 
        scanf("%d %d", &p[i].at, &p[i].bt); 
        p[i].rt = p[i].bt;   // Initialize Remaining Time = Burst Time 
    } 
//   Step 3: Input Time Quantum 
    printf("Enter Time Quantum: "); 
    scanf("%d", &tq); 
    //   Initialize all helper variables 
    int completed = 0, time = 0; 
    int queue[100], front = 0, rear = 0; // Ready queue 
    int visited[n], is_completed[n]; 
    for (int i = 0; i < n; i++) { 
        visited[i] = 0;       // Marks if process has entered the ready queue 
        is_completed[i] = 0;  // Marks if process has finished execution 
    } 
    //   Step 4: Find first arriving process (to start CPU time) 
    int first = 0; 
    for (int i = 1; i < n; i++) { 
        if (p[i].at < p[first].at) 
            first = i; 
    } 
   time = p[first].at;              // Start time from earliest arrival 
    queue[rear++] = first;           // Add first process to queue 
    visited[first] = 1; 
    float total_tat = 0, total_wt = 0;   // For calculating averages later 
    //   Step 5: Execute processes until all are completed 
    while (completed != n) { 
        // If queue is empty → CPU is idle 
        if (front == rear) { 
            int next_arrival = -1, min_at = 9999; 
            // Find next process that will arrive 
            for (int i = 0; i < n; i++) { 
                if (!is_completed[i] && !visited[i] && p[i].at < min_at) { 
                    min_at = p[i].at;//0 
                    next_arrival = i; 
                }            } 
// Move time forward to next process arrival 
            if (next_arrival != -1) { 
                time = p[next_arrival].at; 
                queue[rear++] = next_arrival; 
                visited[next_arrival] = 1; 
            } 
            continue; 
        } 
        //   Dequeue process for execution 
        int idx = queue[front++]; 
        if (front == 100) front = 0;  // Handle queue circularly 
        //   Case 1: Process needs more than 1 quantum 
        if (p[idx].rt > tq) { //p1=4 tq=3 3-> 1 
            time += tq;//0+3 = 3 
            p[idx].rt -= tq;// 1 
        }  
        //   Case 2: Process finishes within this quantum   3 p1=3 
        else { 
            time += p[idx].rt;//3 
            p[idx].rt = 0;//0 
            p[idx].ct = time;                // Completion Time 
            p[idx].tat = p[idx].ct - p[idx].at; // Turnaround Time = CT - AT 
            p[idx].wt = p[idx].tat - p[idx].bt; // Waiting Time = TAT – BT 
total_tat += p[idx].tat; 
            total_wt += p[idx].wt; 
 
            is_completed[idx] = 1;  // Mark process as done 
            completed++; 
        } 
 //   Step 6: Add newly arrived processes to the ready queue 
        for (int j = 0; j < n; j++) { 
            if (p[j].at <= time && !visited[j] && !is_completed[j]) { 
                queue[rear++] = j; 
                if (rear == 100) rear = 0; 
                visited[j] = 1; 
            }     } 
//   Step 7: If current process still needs CPU time → re-enqueue it 
        if (p[idx].rt > 0) { 
            queue[rear++] = idx; 
            if (rear == 100) rear = 0; 
        }    } 
//   Step 8: Display final table and averages 
    printf("\n--------------------------------------------------------\n"); 
    printf("PID\tAT\tBT\tCT\tTAT\tWT\n"); 
    printf("--------------------------------------------------------\n"); 
    for (int i = 0; i < n; i++) { 
        printf("%d\t%d\t%d\t%d\t%d\t%d\n", 
               p[i].pid, p[i].at, p[i].bt, p[i].ct, p[i].tat, p[i].wt); 
    } 
    printf("--------------------------------------------------------\n"); 
    printf("Average Turnaround Time: %.2f\n", total_tat / n);  
    printf("Average Waiting Time: %.2f\n", total_wt / n); 
    return 0; 
} 
 
 
 
 
 
 
 
 
4a.  
#include <stdio.h>               //printf() 
#include <pthread.h>             //pthread function 
#include <semaphore.h>           //sem_t, sem_wait, sem_post 
#include <unistd.h>              //sleep() 
#include <stdlib.h>              //rand() and srand() 
#define BUFFER_SIZE 5            // size of circular buffer 
int buffer[BUFFER_SIZE]; 
int in = 0, out = 0;             // buffer index positions 
sem_t empty;                     // counts empty slots 
sem_t full;                      // counts filled slots 
pthread_mutex_t mutex;           // mutex for critical section 
// Producer Thread Function 
void* producer(void* arg) 
{ 
    int item; 
    while(1)                         // for(int i=0;i<10;i++) 
    { 
        item = rand() % 100;         // produce random item 
        sem_wait(&empty);            // wait until at least 1 empty slot 
        pthread_mutex_lock(&mutex);  // lock buffer for exclusive access 
        buffer[in] = item;           // insert item 
        printf("Produced: %d\n", item); 
        in = (in + 1) % BUFFER_SIZE; // circular increment 1 2 
        pthread_mutex_unlock(&mutex); // unlock buffer 
        sem_post(&full);              // increase count of full slots 
        sleep(1);                      // simulate production delay 
    } 
    // return NULL; // exit thread- for loop termination 
} 
// Consumer Thread Function 
void* consumer(void* arg) 
{ 
    int item; 
    while(1)                          // for(int i=0;i<10;i++) 
    { 
        sem_wait(&full);             // wait until at least 1 full slot  1 
        pthread_mutex_lock(&mutex);  // lock buffer 
        item = buffer[out];          // remove item 
        printf("Consumed: %d\n", item); 
        out = (out + 1) % BUFFER_SIZE; // circular increment   1234567 
pthread_mutex_unlock(&mutex); // unlock buffer 
sem_post(&empty);             
// increase count of empty slots 
sleep(1);                     
} 
// simulate consumption delay 
// return NULL; // exit thread- for loop termination 
} 
int main() 
{ 
pthread_t prodThread, consThread; 
// initialize semaphores and mutex 
sem_init(&empty, 0, BUFFER_SIZE); // initially all slots empty 
sem_init(&full, 0, 0);           
 // initially no slot full 
pthread_mutex_init(&mutex, NULL); 
// create producer and consumer threads 
pthread_create(&prodThread, NULL, producer, NULL); 
pthread_create(&consThread, NULL, consumer, NULL); 
// join threads (not reached, infinite loop) 
pthread_join(prodThread, NULL); 
pthread_join(consThread, NULL); 
return 0; 
} 
 
4b. 
#include <stdio.h> 
#include <pthread.h> 
#include <semaphore.h> 
#include <unistd.h> 
#include <stdint.h> // Include for intptr_t 
// Shared variables 
int readcount = 0;       // Count of active readers 
int shared_data = 0;     // Shared data resource 
// Semaphores and mutex 
sem_t wsem;              // Semaphore to control writer access 
pthread_mutex_t mutex;    
void READUNIT(int reader_id) {  //0 
    printf("Reader %d is reading the data: %d\n", reader_id, shared_data); 
    sleep(1); } 
void WRITEUNIT(int writer_id) {  //1 
    shared_data++; // Modify the shared resource 0 -> 1, 2 , 3 
    printf("Writer %d has written data: %d\n", writer_id, shared_data); 
    sleep(1); // Simulate time taken to write 
} 
// Reader function 
void* reader(void* arg) { 
    int reader_id = (intptr_t)arg; // Use intptr_t for safe pointer casting 
    while (1) { 
        // Entry section //0 
        pthread_mutex_lock(&mutex); 
        readcount++; //1 
        if (readcount == 1) // First reader locks the writer 
            sem_wait(&wsem); 
        pthread_mutex_unlock(&mutex); 
        // Critical section: Reading 
        READUNIT(reader_id); 
        // Exit section 
        pthread_mutex_lock(&mutex); 
        readcount--; 
        if (readcount == 0) // Last reader unlocks the writer 
            sem_post(&wsem); 
        pthread_mutex_unlock(&mutex); 
  sleep(1); 
    } } 
// Writer function 
void* writer(void* arg) { 
    int writer_id = (intptr_t)arg; 
    while (1) { 
        // Entry section 
        sem_wait(&wsem); // Only one writer at a time 
        // Critical section: Writing 
        WRITEUNIT(writer_id); 
        // Exit section 
        sem_post(&wsem); // Release the writer lock 
        sleep(1); 
    } } 
int main() { 
    // Initialization 
    pthread_t rtid[5], wtid[2];  
    int reader_ids[5] = {1, 2, 3, 4, 5}; 
    int writer_ids[2] = {1, 2}; 
    // Initialize semaphore and mutex 
    sem_init(&wsem, 0, 1); 
    pthread_mutex_init(&mutex, NULL); 
    // Create reader threads 
    for (int i = 0; i < 5; i++) { 
        pthread_create(&rtid[i], NULL, reader, (void*)(intptr_t)reader_ids[i]); 
    } 
    // Create writer threads 
    for (int i = 0; i < 2; i++) { 
        pthread_create(&wtid[i], NULL, writer, (void*)(intptr_t)writer_ids[i]); 
    } 
    // Join threads (in a real scenario, we would join to avoid premature exit) 
    for (int i = 0; i < 5; i++) { 
        pthread_join(rtid[i], NULL); 
    } 
    for (int i = 0; i < 2; i++) { 
        pthread_join(wtid[i], NULL); 
    } 
    // Cleanup 
    pthread_mutex_destroy(&mutex); 
    sem_destroy(&wsem); 
    return 0; 
} 
 
 
5. Implement the C program for Deadlock Avoidance Algorithm: Bankers Algorithm 
#include <stdio.h> 
#include <stdbool.h> // For using bool type 
#define MAX_PROCESSES 10 
#define MAX_RESOURCES 10 
int main() { 
    int num_processes, num_resources; 
    int available[MAX_RESOURCES]; 
    int max[MAX_PROCESSES][MAX_RESOURCES]; 
    int allocation[MAX_PROCESSES][MAX_RESOURCES]; 
    int need[MAX_PROCESSES][MAX_RESOURCES]; 
    bool finish[MAX_PROCESSES]; 
    int safe_sequence[MAX_PROCESSES]; 
    int work[MAX_RESOURCES]; 
    printf("Enter the number of processes: "); 
    scanf("%d", &num_processes); 
    printf("Enter the number of resources: "); 
    scanf("%d", &num_resources); 
    printf("Enter the available resources (e.g., R1 R2 R3): "); 
    for (int i = 0; i < num_resources; i++) { 
        scanf("%d", &available[i]); 
    } 
    printf("Enter the allocation matrix (P x R): \n"); 
    for (int i = 0; i < num_processes; i++) { 
        printf("For Process P%d: ", i); 
        for (int j = 0; j < num_resources; j++) { 
            scanf("%d", &allocation[i][j]);  }   } 
    printf("Enter the maximum matrix (P x R): \n"); 
    for (int i = 0; i < num_processes; i++) { 
        printf("For Process P%d: ", i); 
        for (int j = 0; j < num_resources; j++) { 
            scanf("%d", &max[i][j]);   }   } 
    for (int i = 0; i < num_processes; i++) { 
        for (int j = 0; j < num_resources; j++) { 
            need[i][j] = max[i][j] - allocation[i][j]; } } 
    for (int i = 0; i < num_resources; i++) { 
        work[i] = available[i];  } 
    for (int i = 0; i < num_processes; i++) { 
        finish[i] = false;  } 
  int count = 0; 
    int safe_seq_index = 0; 
  while (count < num_processes) { 
        bool found_process = false; 
        for (int p = 0; p < num_processes; p++) { 
            if (finish[p] == false) { 
                bool can_execute = true; 
                for (int r = 0; r < num_resources; r++) { 
   if (need[p][r] > work[r]) { 
                        can_execute = false; 
                        break  }  } 
  if (can_execute) { 
                    for (int r = 0; r < num_resources; r++) { 
                        work[r] += allocation[p][r]; 
                    } 
                    finish[p] = true; 
                    safe_sequence[safe_seq_index++] = p; 
                    count++; 
                    found_process = true  }}  } 
 if (!found_process && count < num_processes) { 
            printf("\nSystem is in an UNSAFE state. No safe sequence exists.\n"); 
            return 0;   }  } 
   printf("\nSystem is in a SAFE state. Safe sequence: "); 
    for (int i = 0; i < num_processes; i++) { 
        printf("P%d", safe_sequence[i]); 
        if (i < num_processes - 1) { 
            printf(" -> "); 
        } 
    } 
    printf("\n"); 
  return 0; 
} 
 
 
 
 
 
 
 
 
 
 
 
6. Implement the C program for Page Replacement Algorithms: FCFS, LRU, and Optimal 
for frame size as minimum three. 
#include <stdio.h> 
#include <stdbool.h> 
#include <limits.h> 
void printFrames(int frames[], int frame_size) { 
    for (int i = 0; i < frame_size; i++) { 
        if (frames[i] == -1) { 
            printf(" - "); 
        } else { 
            printf(" %d ", frames[i]); 
        } 
    } 
    printf("\n"); 
} 
void fcfs(int pages[], int n_pages, int frame_size) { 
    int frames[frame_size]; 
    for (int i = 0; i < frame_size; i++) { 
        frames[i] = -1; // Initialize frames as empty 
    } 
  int page_faults = 0; 
    int frame_index = 0; // Pointer to the oldest page 
  printf("\n--- FCFS Page Replacement ---\n"); 
    for (int i = 0; i < n_pages; i++) { 
        int current_page = pages[i]; 
        bool found = false; 
        for (int j = 0; j < frame_size; j++) { 
            if (frames[j] == current_page) { 
                found = true; 
                break; 
            }    } 
  if (!found) { 
            page_faults++; 
            frames[frame_index] = current_page; 
            frame_index = (frame_index + 1) % frame_size;  
        } 
        printf("Page %d: ", current_page); 
        printFrames(frames, frame_size); 
    } 
    printf("Total FCFS Page Faults: %d\n", page_faults); 
} 
void lru(int pages[], int n_pages, int frame_size) { 
    int frames[frame_size]; 
    int recency[frame_size]; // Stores the last access time (index in pages array) 
    for (int i = 0; i < frame_size; i++) { 
        frames[i] = -1; 
        recency[i] = -1; 
    } 
  int page_faults = 0; 
 printf("\n--- LRU Page Replacement ---\n"); 
    for (int i = 0; i < n_pages; i++) { 
        int current_page = pages[i]; 
        bool found = false; 
        int found_index = -1; 
        for (int j = 0; j < frame_size; j++) { 
            if (frames[j] == current_page) { 
                found = true; 
                found_index = j; 
                break; 
            }     } 
if (!found) { 
               page_faults++; 
            int lru_index = -1; 
            int min_recency = INT_MAX; 
            for (int j = 0; j < frame_size; j++) { 
                if (frames[j] == -1) { // Empty frame available 
                    lru_index = j; 
                    break; 
                } 
                if (recency[j] < min_recency) { 
                    min_recency = recency[j]; 
                    lru_index = j; 
                } 
            } 
            frames[lru_index] = current_page; 
            recency[lru_index] = i; // Update recency 
        } else { 
            recency[found_index] = i;        } 
        printf("Page %d: ", current_page); 
        printFrames(frames, frame_size); 
    } 
    printf("Total LRU Page Faults: %d\n", page_faults); 
} 
void optimal(int pages[], int n_pages, int frame_size) { 
    int frames[frame_size]; 
    for (int i = 0; i < frame_size; i++) { 
        frames[i] = -1; 
    } 
   int page_faults = 0; 
    printf("\n--- Optimal Page Replacement ---\n"); 
    for (int i = 0; i < n_pages; i++) { 
        int current_page = pages[i]; 
        bool found = false; 
        for (int j = 0; j < frame_size; j++) { 
            if (frames[j] == current_page) { 
                found = true; 
                break;   }   } 
   if (!found) { 
            page_faults++; 
            int replace_index = -1; 
            bool empty_frame_found = false; 
            for (int j = 0; j < frame_size; j++) { 
                if (frames[j] == -1) { 
                    replace_index = j; 
                    empty_frame_found = true; 
                    break; 
                }     } 
if (!empty_frame_found) { 
                int farthest_future_index = -1; 
                int max_future_use = -1; 
  for (int j = 0; j < frame_size; j++) { 
                    int next_use = INT_MAX; // Initialize with a large value 
                    for (int k = i + 1; k < n_pages; k++) { 
                        if (frames[j] == pages[k]) { 
                            next_use = k; 
                            break; 
                        }                    } 
                    if (next_use > max_future_use) { 
                        max_future_use = next_use; 
                        farthest_future_index = j; 
                    } } 
                replace_index = farthest_future_index; 
            } 
            frames[replace_index] = current_page; 
        } 
        printf("Page %d: ", current_page); 
        printFrames(frames, frame_size); 
    } 
    printf("Total Optimal Page Faults: %d\n", page_faults); 
} 
int main() { 
    int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1}; 
    int n_pages = sizeof(pages) / sizeof(pages[0]); 
    int frame_size = 3;  
    fcfs(pages, n_pages, frame_size); 
    lru(pages, n_pages, frame_size); 
    optimal(pages, n_pages, frame_size); 
    return 0; 
} 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
7a. #include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <fcntl.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <string.h> 
#define FIFO1 "/tmp/fifo1" 
#define FIFO2 "/tmp/fifo2" 
void countDetails(const char* sentence, int* chars, int* words, int* lines) { 
int i = 0; 
*chars = *words = *lines = 0; 
while (sentence[i] != '\0') { 
(*chars)++; 
if (sentence[i] == ' ' || sentence[i] == '\n') { 
(*words)++;  } 
if (sentence[i] == '\n') { 
(*lines)++;  } 
i++;  } 
if (sentence[i-1] != ' ' && sentence[i-1] != '\n') { 
(*words)++;   } 
if (sentence[i-1] != '\n') { 
(*lines)++;   } } 
int main() { 
char buffer[1024]; 
int fd1, fd2; 
pid_t pid; 
mkfifo(FIFO1, 0666); // FIFO for Process 1 to write and Process 2 to read 
mkfifo(FIFO2, 0666); // FIFO for Process 2 to write and Process 1 to read 
pid = fork(); // Create a child process 
if (pid > 0) { 
printf("Process 1: Enter a sentence: "); 
fgets(buffer, sizeof(buffer), stdin); 
fd1 = open(FIFO1, O_WRONLY); 
write(fd1, buffer, strlen(buffer) + 1); 
close(fd1); 
fd2 = open(FIFO2, O_RDONLY); 
read(fd2, buffer, sizeof(buffer)); 
printf("Process 1: Result from Process 2 -\n%s\n", buffer); 
close(fd2); 
} else if (pid == 0) { 
int chars, words, lines; 
char result[256]; 
fd1 = open(FIFO1, O_RDONLY); 
read(fd1, buffer, sizeof(buffer)); 
close(fd1); 
countDetails(buffer, &chars, &words, &lines); 
FILE *file = fopen("output.txt", "w"); 
fprintf(file, "Characters: %d\nWords: %d\nLines: %d\n", chars, words, lines); 
fclose(file); 
fd2 = open(FIFO2, O_WRONLY); 
snprintf(result, sizeof(result), "Characters: %d\nWords: %d\nLines: %d", chars, words, 
lines); 
write(fd2, result, strlen(result) + 1); 
close(fd2); 
} 
unlink(FIFO1); 
unlink(FIFO2); 
return 0; 
} 
7b. // Reader Program (read_from_shm.c) 
#include <stdio.h> 
#include <sys/ipc.h> 
#include <sys/shm.h> 
#include <stdlib.h> 
int main() { 
key_t key = ftok("shmfile", 65); 
int shmid = shmget(key, 1024, 0666 | IPC_CREAT); 
if (shmid == -1) { 
perror("Shared memory access failed"); 
exit(1); 
} 
char *shared_memory = (char*) shmat(shmid, (void*)0, 0); 
if ((void*)shared_memory == (void*)-1) { 
perror("Shared memory attach failed"); 
exit(1); 
} 
printf("Data read from shared memory: %s\n", shared_memory); 
if (shmdt(shared_memory) == -1) { 
perror("Shared memory detach failed"); 
exit(1); 
} 
if (shmctl(shmid, IPC_RMID, NULL) == -1) { 
perror("Shared memory removal failed"); 
exit(1); 
} 
return 0; 
} 
// Writer Program (write_to_shm.c) 
#include <stdio.h> 
#include <sys/ipc.h> 
#include <sys/shm.h> 
#include <string.h> 
#include <stdlib.h> 
int main() { 
key_t key = ftok("shmfile", 65); 
int shmid = shmget(key, 1024, 0666 | IPC_CREAT); 
if (shmid == -1) { 
perror("Shared memory creation failed"); 
exit(1); 
} 
char *shared_memory = (char*) shmat(shmid, (void*)0, 0); 
if ((void*)shared_memory == (void*)-1) { 
perror("Shared memory attach failed"); 
exit(1); 
} 
printf("Enter data to write into shared memory: "); 
fgets(shared_memory, 1024, stdin); // Read input and store it in shared memory 
if (shmdt(shared_memory) == -1) { 
perror("Shared memory detach failed"); 
exit(1); 
} 
printf("Data written to shared memory.\n"); 
return 0; 
} 
8. Practical no 8 Implement the C program for Disk Scheduling Algorithms: SSTF, SCAN, 
C-Look considering the initial head position moving away from the spindle. 
SSTF:- 
#include <stdio.h> 
#include <stdlib.h> 
#define MAX_REQUESTS 100 
void SSTF(int requests[], int num_requests, int initial_head) { 
int completed[MAX_REQUESTS] = {0}; 
int current_head = initial_head; 
int total_distance = 0; 
printf("\n\n Seek Sequence: "); 
for (int i = 0; i < num_requests; i++) { 
int min_index = -1; 
int min_distance = 1000000; // Large number 
// Find the closest request 
for (int j = 0; j < num_requests; j++) { 
if (!completed[j]) { 
int distance = abs(requests[j] - current_head); 
if (distance < min_distance) { 
min_distance = distance; 
min_index = j; 
}}} 
if (min_index != -1) { 
total_distance += min_distance; 
current_head = requests[min_index]; 
completed[min_index] = 1; 
printf("%d ", current_head); 
}} 
printf("\n Total Number of Seek Operations = %d\n", total_distance); 
} 
int main() { 
int requests[MAX_REQUESTS]; 
int num_requests, initial_head; 
printf("\nEnter number of disk requests: "); 
scanf("%d", &num_requests); 
printf("Enter disk requests: "); 
for (int i = 0; i < num_requests; i++) { 
scanf("%d", &requests[i]); 
} 
printf("Enter initial head position: "); 
scanf("%d", &initial_head); 
SSTF(requests, num_requests, initial_head); 
return 0; 
}  
SCAN.c 
#include <stdio.h> 
#include <stdlib.h> 
#define MAX_REQUESTS 100 
void SCAN(int requests[], int num_requests, int initial_head, int direction) { 
int total_distance = 0; 
int current_head = initial_head; 
// Sort the requests 
for (int i = 0; i < num_requests - 1; i++) { 
for (int j = i + 1; j < num_requests; j++) { 
if (requests[i] > requests[j]) { 
int temp = requests[i]; 
requests[i] = requests[j]; 
requests[j] = temp; 
}}} 
printf("\n\n Seek Sequence: "); 
if (direction == 0) { // Moving left 
// Service requests moving left 
for (int i = num_requests - 1; i >= 0; i--) { 
if (requests[i] <= current_head) { 
total_distance += abs(requests[i] - current_head); 
current_head = requests[i]; 
printf("%d ", current_head); 
} 
} 
total_distance += abs(current_head - 0); 
current_head = 0; 
printf("0 ");  
for (int i = 0; i < num_requests; i++) { 
if (requests[i] > 0) { 
total_distance += abs(requests[i] - current_head); 
current_head = requests[i]; 
printf("%d ", current_head); 
}}} else { // Moving right 
// Service requests moving right 
for (int i = 0; i < num_requests; i++) { 
if (requests[i] >= current_head) { 
total_distance += abs(requests[i] - current_head); 
current_head = requests[i]; 
printf("%d ", current_head); 
} 
} 
// Move to the end of the disk (disk size = 200) 
total_distance += abs(current_head - 200); 
current_head = 200; 
printf("200 "); // Move to the end 
// Then service all requests < disk size 
for (int i = num_requests - 1; i >= 0; i--) { 
if (requests[i] < current_head) { 
total_distance += abs(requests[i] - current_head); 
current_head = requests[i]; 
printf("%d ", current_head); 
} 
} 
} 
printf("\n Total number of seek operations = %d\n", total_distance); 
} 
int main() { 
int requests[MAX_REQUESTS]; 
int num_requests, initial_head, direction; 
printf("\nEnter number of disk requests: "); 
scanf("%d", &num_requests); 
printf("Enter disk requests: "); 
for (int i = 0; i < num_requests; i++) { 
scanf("%d", &requests[i]); 
} 
printf("Enter initial head position: "); 
scanf("%d", &initial_head); 
printf("Enter direction (0 for left, 1 for right): "); 
scanf("%d", &direction); 
SCAN(requests, num_requests, initial_head, direction); 
return 0; 
}